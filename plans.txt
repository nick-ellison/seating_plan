1. Decide the shape of the codebase

Monorepo, two main parts:

backend/ – FastAPI app + solver module

frontend/ – React/Next.js app

Keep the current Python script as a reference in sandbox/ or experiments/ so you can cherry-pick logic.

2. Extract and harden the solver (no web yet)

Goal: a clean, tested Python module that does one thing:
guests + tables + weights → seating plan + metrics.

Tasks:

Create backend/seating_solver/ with:

data classes / Pydantic models for Guest, Table, SeatingPlan

your arrange_seating logic, tidied and parameterised

Write unit tests:

small synthetic datasets (3–8 guests) where the “right” answer is obvious

tests for:

must-not never violated when solvable

wants increases score when neighbours sit together

adjacent singles counted correctly

alternating table detection

Add a simple CLI:

python -m seating_solver sample.json
This lets you debug without touching the web stack.

Once this is solid, everything else is “just I/O”.

3. Wrap the solver in an API (FastAPI)

Goal: reproducible, documented HTTP interface.

Tasks:

Set up FastAPI app in backend/app/main.py.

Define Pydantic models mirroring your tech doc:

GuestIn, TableIn, WeightsIn, SeatingPlanOut

Implement one endpoint:

POST /api/seating/generate

Validates payload → calls solver → returns SeatingPlanOut

Add a trivial health check: GET /api/health.

Enable CORS for localhost:3000 (or whatever the frontend runs on).

Add automated tests for the endpoint (pytest + httpx) using small datasets.

At this point you can curl or Postman a JSON payload and get a plan back.

4. Build a minimal frontend “developer UI”

Goal: something ugly-but-functional that calls the API and shows the result.

Slice 1:

Bootstrapped React/Next app:

a single page with:

textarea for JSON payload (or a “use sample data” button)

button “Generate seating”

shows the returned plan as pretty JSON

Slice 2:

Replace raw JSON input with simple forms:

number of tables, capacity, shape

“load sample guest list” button (hard-coded in frontend)

Render tables as plain lists:

Table 1: then a list of guests in order

show metrics in a summary panel

Don’t worry about CSV or drag-and-drop yet; just prove E2E is working.

5. Add CSV upload + validation

Goal: match your current workflow with the script.

Backend:

Implement POST /api/guests/import-csv

Return guests + warnings as per tech doc.

Frontend:

Simple CSV upload component:

File chooser

On upload → call API → show:

guest table (editable)

warnings list

Glue:

Allow user to:

upload CSV → tweak guests in UI → then press “Generate seating” → POST full guests + tables to /seating/generate.

This gives you a full “planner workflow” already: CSV → validate → solve → see simple seating.

6. Add visual seating layout

Goal: intuitive view of who is where.

Steps:

Decide on visual library:

easiest start is plain SVG using CSS Grid / absolute positioning.

later consider Konva.js if you want drag-and-drop.

Implement a TableView component:

receives shape, capacity, and seats[] with guest objects

for round tables: place labels around a circle using basic trigonometry

for trestle: top/bottom rows

Add colour/icon cues:

singles highlighted

couples maybe with a small icon

optional “constraint warnings” overlay (for debug)

Now you can visually inspect whether the solver is behaving.

7. Start tuning and adding UX niceties

Once E2E is there:

Add a panel showing metrics:

mustNotViolations, wantsSatisfied, adjacentSingles, etc.

Add sliders / toggles for weights:

e.g. “Singles together” vs “Couples together”

Feed these as weights to the API.

Add a “Re-run with new seed” button to explore alternatives.

This is where it starts feeling like a real product rather than a tool.

8. Infrastructure, CI and environments

Once happy locally:

Containerise backend (Dockerfile).

Add minimal CI:

run pytest for backend

run frontend tests / build

Set up environments:

dev: your playground

prod: stable environment for demos

Hosting options:

Backend: Fly.io / Render / small EC2

Frontend: Vercel / Netlify

You don’t need to over-engineer: one small box running FastAPI + Postgres (if you add persistence later) is fine.

9. How to slice this into iterations

If you like very concrete milestones:

Iteration 1 – Solver Module

Extract & test solver; JSON in/out via CLI.

Iteration 2 – Solver API

FastAPI endpoint; curl works with sample guests.

Iteration 3 – Basic Web UI

Hard-coded guests and tables; API call; text seating output.

Iteration 4 – CSV + Validation

Upload CSV, see guests, generate seating.

Iteration 5 – Visual Layout

Render tables graphically; show metrics.

Iteration 6 – Weights & UX

Sliders, re-run, nicer feedback, polish.

Each iteration gives you something demo-able and reduces the risk you vanish into backend perfectionism for a month.